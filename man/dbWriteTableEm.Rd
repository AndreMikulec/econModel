% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AmerAssocIndividInvestorsAAII.R
\name{dbWriteTableEM}
\alias{dbWriteTableEM}
\title{Insert or Append to a New or Current Table or Table partition.}
\usage{
dbWriteTableEM(
  conn,
  DfName = substitute(Df),
  Df,
  PartitionOf = character(),
  PartBoundValue = character(),
  PartKeyCol = character(),
  PrimaryKey = character(),
  Indexes = list(),
  FillNull = TRUE,
  lowerDfName = TRUE,
  lowerColNames = TRUE,
  replaceDotUsingUnderscore = TRUE,
  display = TRUE,
  exec = TRUE,
  ...
)
}
\arguments{
\item{conn}{A DBIConnection object, as returned by dbConnect().}

\item{DfName}{String.  Default is substitute(Df). The name of the table to which the data frame is to be loaded.}

\item{Df, }{data.frame. Required. To be loaded to the database.}

\item{PartitionOf}{String.  If the table is (or to be) a participant as a Partition, then this table is a partion of the this partitioned table "PartitionOf".}

\item{PartBoundValue}{String. If the table is (or to be) a participant as a Partition, then this is a partition bound as a List value.}

\item{PartKeyCol}{String.  If the table is (or to be is) a Partitioned table is of that List partition and the partition key column.}

\item{PrimaryKey}{Vector of Strings.  If present, then of the [to be] primary-keyed table, this is the the vector values (in order) are the primary-keyed columns. The name of the primary key is taken from the name of the vector.}

\item{Indexes}{List of "Vector of Strings".  If present, then of the [to be] indexed table, this is the the vector values (in order) are the indexed columns. The name of the index is taken from the name of the vector.}

\item{FillNull}{Logical.  Default is TRUE. Should new db present fields be added to the data.frame before it is loaded?}

\item{lowerDfName}{Logical. Default is TRUE. Make the target database table name to be in lowercase.}

\item{lowerColNames}{Logical. Default is TRUE. Make the target database table column names to be in lowercase.}

\item{replaceDotUsingUnderscore}{Logical. Default is TRUE. Make the target database table column names internal "dots" be converted to underscores(_).}

\item{display}{Logical. Whether to display the query (defaults to \code{TRUE}).}

\item{exec}{Logical. Whether to execute the query (defaults to \code{TRUE}).'}

\item{...}{Dots. Other parameters passed to R CRAN package DBI dbWriteTable.}

\item{RowNames}{Logical. Default is FALSE.  Should the row names be loaded as a separate column? (unlike the original dbWriteTable, default is FALSE).}
}
\description{
\preformatted{
Thick wrapper over R CRAN package caroline function dbWriteTable2.

This is R cran package "caroline" function "dbWriteTable2" with modifications
JAN 2021
https://github.com/cran/caroline/blob
/af201137e4a31d675849291a1c9c07a0933b85de/R/database.R

modifications

1. add.id domain specific feature is removed
2. pg.update.seq domain specific feature is removed
3. "ORDER BY id DESC LIMIT 1" is replaced by " WHERE FALSE "
4. function "names" upon "df" is replaced with the modern "colnames"
   where appropriate
5. function "names" is replaced with the safer "Names"
6. "nv" is replaced with "nameVect".
7. Calls to DBI are called through "PACKAGE::".
   These are the (working) dbListFields, dbSendQuery, dbColumnInfo,
   dbClearResult, and dbWriteTable
8. If a column exists in the local table.name(data.frame) but does not
   exist on the server
   then it is added to the server's table fields.
9. Fix and Put back the type mismatch test.
10. Added drop = F to prevent dropping to a vector.
11. Changed message - not in fields of '", table.name,"' table. Omiting
                 To - not in fields of '", table.name,"' Adding.

For consistency and understandability renamed db.col.info to fields.info.
For consistency and understandability renamed db.precisions to fields.precisions.
For consistency and understandability renamed db.sclasses to fields.sclasses.
Since static, moved closer to the top calls to DBI::dbSendQuery, DBI::dbColumnInfo and DBI::dbClearResult
Moved other non-changing code to near the top.
}
}
\examples{
\dontrun{
mtcars2 <- mtcars
mtcars2[["model"]] <- rownames(mtcars2)
mtcars2 <- DataCombine::MoveFront(mtcars2, Var = "model")
mtcars2[["vs"]] <- as.logical(mtcars2[["vs"]])
mtcars2[["gear"]] <- as.integer(mtcars2[["gear"]])
mtcars2[["carb"]] <- zoo::as.Date(mtcars2[["carb"]])
rownames(mtcars2) <- NULL
#
# Creates the table (with zero rows).
# Appends data (with the Df having the same columns that the server).
mtcars2s <- mtcars2[1:5,]
dbWriteTableEM(get("connEM"), DfName = "mtcars",  Df = mtcars2s, PartKeyDef = "LIST (gear)", PrimaryKey = c("gear", "model"), Indexes = list(gear_model_vs = c("gear", "model", "vs")))

# Appends data (with the Df having less columns that the server database).
# Those server columns, that are not found in the Df, are added to the Df.
mtcars2lDf <- mtcars2[6:10, "model", drop = F]
dbWriteTableEM(get("connEM"), DfName = "mtcars", Df = mtcars2lDf)

# Appends data (with the server database having less columns that the Df).
# Those Df columns, that are not found in the server, are added to the sever.
mtcars2lSv <- {DfNew <- mtcars2[11:15, c("model","vs", "am", "gear", "carb")]
               colnames(DfNew) <- paste0(colnames(DfNew),"_new")
               DfNew[["model"]] <- DfNew[["model_new"]]
               DfNew <- DataCombine::MoveFront(DfNew, Var = "model")
               DfNew
              }; rm(DfNew)
dbWriteTableEM(get("connEM"), DfName = "mtcars", Df = mtcars2lSv)
}
}
