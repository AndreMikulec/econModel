% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AmerAssocIndividInvestorsAAII.R
\name{dbdfMatchColsEM}
\alias{dbdfMatchColsEM}
\title{Bind New Columns to a Server or Local and Re-Order Columns}
\usage{
dbdfMatchColsEM(
  connName,
  name = substitute(value),
  value,
  temporary = FALSE,
  env,
  display = TRUE,
  exec = TRUE
)
}
\arguments{
\item{connName}{String.  Default is "connEM". Contains the name of the variable that contains the name of the "connection" in the environment "env".}

\item{name}{a character string specifying a table name.}

\item{value}{a data.frame (or coercible to data.frame).}

\item{temporary}{Logical. Default is FALSE, If TRUE, then look for the "conn" object "name" in the temporary namespace.}

\item{env}{Environment.  Default is the .Global environment.  This is the environment to return the connection object "connEM".}

\item{display}{Logical. Whether to display the query (defaults to TRUE).}

\item{exec}{Logical. Whether to execute the query (defaults to TRUE).}
}
\value{
data.frame with more columns and/or re-ordered columns. The server "name" may get more columns.
}
\description{
\preformatted{
Based on the idea of the  R CRAN package caroline function dbWriteTable2.

\url{https://github.com/cran/caroline/blob/af201137e4a31d675849291a1c9c07a0933b85de/R/database.R}

Match the the Server/data.frame columns with each other.
Create new columns as necessary. Verify/Make the data.frame
columns order match that of the Server table order.
Inspired by the R CRAN package Caroline.
}
}
\examples{
\dontrun{

mtcars2 <- mtcars
mtcars2[["model"]] <- rownames(mtcars2)
mtcars2 <- DataCombine::MoveFront(mtcars2, Var = "model")
mtcars2[["vs"]] <- as.logical(mtcars2[["vs"]])
mtcars2[["gear"]] <- as.integer(mtcars2[["gear"]])
mtcars2[["carb"]] <- zoo::as.Date(mtcars2[["carb"]])
rownames(mtcars2) <- NULL
#
# Creates the table (with zero rows).
# Appends data (with the value(data.frame) having the same columns
# on the server).
mtcars2s <- mtcars2[1:5,]
dbdfMatchColsEM(name = "mtcars",  value = mtcars2s, PartKeyDef = "LIST (gear)", PrimaryKey = c("gear", "model"), Indexes = list(gear_model_vs = c("gear", "model", "vs")))

# Appends data (with the value(data.frame) having less columns
# than that of the server database).
# Those server columns, that are not found in the value(data.frame),
# are added to the value(data.frame).
mtcars2lDf <- mtcars2[6:10, "model", drop = F]
dbdfMatchColsEM(name = "mtcars", value = mtcars2lDf)

# Appends data (with the server database having less columns
# than that of the value(data.frame)).
# Those value(data.frame) columns, that are not found in the server, are added to the server.
mtcars2lSv <- {DfNew <- mtcars2[11:15, c("model","vs", "am", "gear", "carb")]
               colnames(DfNew) <- paste0(colnames(DfNew),"_new")
               DfNew[["model"]] <- DfNew[["model_new"]]
               DfNew <- DataCombine::MoveFront(DfNew, Var = "model")
               DfNew
              }; rm(DfNew)

dbdfMatchColsEM(name = "mtcars", value = mtcars2lSv)
}
}
